---
layout: post
title: 'Alogorithm: Finding Longest Increasing Subsequence using Patience Sort in
  C#'
date: '2012-05-24T18:32:00.000+05:30'
author: Chandermani Arora
tags:
- Data Structures.
- ".Net"
- Patience Sort
- c#
- Algorithm
- Longest Increasing Sequence
modified_time: '2012-05-24T18:34:52.868+05:30'
thumbnail: http://3.bp.blogspot.com/-htX8q66vhxs/T74kxtpoM_I/AAAAAAAAAf0/2m702N5Kifc/s72-c/PatienceSortFlow.png
blogger_id: tag:blogger.com,1999:blog-20117988.post-8676441999779936448
blogger_orig_url: http://chandermani.blogspot.com/2012/05/alogorithm-finding-longest-increasing.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Finding the <a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank">Longest Increasing Sequence</a> is an interesting problem and there are multiple solutions available with varying time complexity. The solution that i plan to share today is the uses of <a href="https://en.wikipedia.org/wiki/Patience_sorting" target="_blank">Patience Sort&nbsp;</a> to find such a sequence. The solution finds <u><b>a particular longest increasing sub-sequence</b></u> as the original sequence may contain more than one such sequence.<br /><br />In 1999 The Bulletin of the American Mathematical Society published <a href="http://www.ams.org/bull/1999-36-04/S0273-0979-99-00796-X/home.html" target="_blank">a paper</a> by David Aldous and Persi Diaconis entitled: “Longest Increasing Subsequences: From Patience Sorting to the Baik-Deift-Johansson Theorem”.<br /><br />I have implemented this solution in C# and derived it from this excellent <a href="http://wordaligned.org/articles/patience-sort" target="_blank">article</a> which provides a Python implementation for the same.<br /><br />This is how patience sort works<br /><br /><ul style="text-align: left;"><li>Take a deck of cards  labeled 1, 2, 3, … , n. The deck is shuffled, cards are turned up one  at a time and dealt into piles on the table, according to the rule</li><li>A  low card may be placed on a higher card (e.g. 2 may be placed on 7), or  may be put into a new pile to the right of the existing piles.</li><li>At  each stage we see the top card on each pile. If the turned up card is  higher than the cards showing, then it must be put into a new pile to  the right of the others.&nbsp;</li></ul>I have left out the part that returns the sorted list of numbers as it is not relevant for the longest sub-sequence problem.<br /><br />The first thing to note here is <br /><blockquote class="tr_bq"><b>Once the cards\numbers are organized into piles. The total number of piles denote the size of longest sub-sequence.</b></blockquote>&nbsp;To get the longest sequence some extra book keeping is required. According to the paper<br /><blockquote class="tr_bq"><br /></blockquote><blockquote><span style="font-size: x-small;">&nbsp;&nbsp;<span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">&nbsp; <b>Lemma 1</b>. With deck π, patience sorting played with the greedy strategy ends with exactly L(π) piles. Furthermore, the game played with any legal strategy ends with at least L(π) piles. So the greedy strategy is optimal and cannot be improved by any look-ahead strategy.<br /><br />&nbsp;&nbsp;&nbsp; <b>Proof</b>. If cards a1 &lt; a2 &lt; … &lt; al appear in increasing order, then under any legal strategy each ai must be placed in some pile to the right of the pile containing ai-1, because the card number on top of that pile can only decrease. Thus the final number of piles is at least l, and hence at least L(π). <b>Conversely, using the greedy strategy, when a card c is placed in a pile other than the first pile, put a pointer from that card to the currently top card c′ &lt; c in the pile to the left. At the end of the game, let al be the card on top of the rightmost pile l. The sequence a1 ← a2 ← … ← al-1 ← al obtained by following the pointers is an increasing subsequence whose length is the number of piles.</b></span></span></blockquote><br />What this means is whenever a card is added to a stack (except first stack), the card should keep a back pointer to the topmost card on the pile on the left.<br /><br />To get a better understanding of the above logic, i have created a diagram detailing the links that get created during the patience sort process for the list of numbers<br /><br /><div style="text-align: center;"><blockquote class="tr_bq"><b>31,16,7,39,5,12,32,18,9,1</b></blockquote></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-htX8q66vhxs/T74kxtpoM_I/AAAAAAAAAf0/2m702N5Kifc/s1600/PatienceSortFlow.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="236" src="http://3.bp.blogspot.com/-htX8q66vhxs/T74kxtpoM_I/AAAAAAAAAf0/2m702N5Kifc/s400/PatienceSortFlow.png" width="400" /></a></div><br />The longest increasing sub-sequence using the above algorithm is <br /><div style="text-align: center;"><blockquote class="tr_bq"><b>5,12,18</b></blockquote></div>The gist for the implementation is available here<br /><script src="https://gist.github.com/2775849.js?file=LongestIncreasingSequence.cs"></script> <br /><br /><br /></div>